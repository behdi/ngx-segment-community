import {
  type EnvironmentProviders,
  type Provider,
  InjectionToken,
  makeEnvironmentProviders,
} from '@angular/core';
import type { MiddlewareFunction, Plugin } from '@segment/analytics-next';
import type { IntegrationsInitOptions } from '@segment/analytics-next/dist/types/browser/settings';
import type { DestinationMiddlewareFunction } from '@segment/analytics-next/dist/types/plugins/middleware';
import { SegmentService } from './segment';

export const enum SegmentConfigKind {
  Settings,
  SMiddleware,
  DMiddleware,
  Plugin,
}

/**
 * Internal wrapper for Segment configuration features.
 *
 * **DO NOT USE DIRECTLY.**
 * This is used under the hood to power the `with*` provider pattern (e.g., `withSettings`, `withPlugins`),
 * ensuring that the correct types of configurations are passed to `provideSegmentAnalytics` in a type-safe manner.
 *
 * @internal
 */
export interface SegmentConfig<Kind extends SegmentConfigKind> {
  /** The internal discriminator used to enforce type safety across features. */
  ɵkind: Kind;

  /** An array of providers that power this specific feature. */
  ɵprovider: Provider[];
}

function makeSegmentConfig<Kind extends SegmentConfigKind>(
  kind: Kind,
  providers: Provider[],
): SegmentConfig<Kind> {
  return {
    ɵkind: kind,
    ɵprovider: providers,
  };
}
/** Represents the mandatory core settings provider generated by {@link withSettings()}. */
export type SegmentSettings = SegmentConfig<SegmentConfigKind.Settings>;

/**
 * Represents an optional behavioral feature provider (e.g., `Plugins`, `Middlewares`)
 * generated by functions like {@link withPlugins()}, {@link withSourceMiddlewares()}
 * or {@link withDestinationMiddlewares()}.
 */
export type SegmentFeatures =
  | SegmentConfig<SegmentConfigKind.SMiddleware>
  | SegmentConfig<SegmentConfigKind.DMiddleware>
  | SegmentConfig<SegmentConfigKind.Plugin>;

export interface SegmentAnalyticsSettings {
  /**
   * The API Key (Write Key) used to identify the source in Segment.
   * @see {@link https://segment.com/docs/connections/find-writekey/ | Locate your Write Key}
   */
  writeKey: string;

  /**
   * If provided, will override the default Segment CDN (https://cdn.segment.com)
   * Use this to proxy requests through your own domain to bypass ad-blockers.
   *
   * @example 'https://analytics.my-domain.com'
   */
  cdnURL?: string;

  /**
   * Defines when the analytics service should initialize.
   * - `automatic`: (Default) Initializes immediately upon service construction.
   * - `manual`: User must call `.initialize()` explicitly. Useful for when user consent
   * is required to start tracking.
   */
  initializationMode?: 'manual' | 'automatic';

  /**
   * Indicates whether debug mode should be turned on.
   *
   * Debug mode logs helpful messages in the console.
   *
   * @see {@link https://www.twilio.com/docs/segment/connections/sources/catalog/libraries/website/javascript#debug | Debug Docs}
   */
  debug?: boolean;

  /**
   * Specifies the length (in milliseconds) of callbacks and helper functions.
   *
   * Useful if you have multiple scripts that need to fire in your callback, or the `trackLink` functions.
   *
   * **NOTE:**
   * If you're triggering ad network conversion pixels, Segment recommends extending timeout to 500 ms to account for slow load times.
   *
   * @see {@link https://www.twilio.com/docs/segment/connections/sources/catalog/libraries/website/javascript#extending-timeout | Timeout Docs}
   */
  timeout?: number;

  /**
   * Whether event sending should be disabled.
   *
   * If set to `true`, all analytics method calls will be a no-op, and no network calls will be initiated.
   *
   * For testing or staging environments, it can be useful to disable your SDK to ensure no events are sent.
   *
   * Defaults to `false`.
   */
  disable?: boolean;

  /**
   * Obfuscates the URL from which your integrations and destination actions are loaded. This can help prevent
   * words that are flagged by ad blockers to not be detected in your URL, enabling the integration to properly
   * load.
   *
   * Defaults to `false`.
   */
  obfuscate?: boolean;

  /**
   * Allows you to customize your integrations with various data.
   *
   * For example, you can configure the delivery strategy of segment, by adding a header
   * to all the requests that are sent to the integration, or you can configure things
   * such as keepalive or batching.
   *
   * @see {@link https://www.twilio.com/docs/segment/connections/sources/catalog/libraries/website/javascript#delivery-strategy-configuration | Delivery Strategy Configuration}
   * @see {@link https://www.twilio.com/docs/segment/connections/sources/catalog/libraries/website/javascript#keepalive | Keepalive Configuration}
   * @see {@link https://www.twilio.com/docs/segment/connections/sources/catalog/libraries/website/javascript#batching | Batching Configuration}
   */
  integrations?: IntegrationsInitOptions;

  /**
   * Allows you to disable the auto-conversion of ISO8061 strings to a Date object before passing it to downstream
   * device-mode integrations.
   *
   * You can set this value to `true` if you'd like to send those strings as they are passed to the event.
   */
  disableAutoISOConversion?: boolean;
}

export const SEGMENT_ANALYTICS_SETTINGS =
  new InjectionToken<SegmentAnalyticsSettings>(
    '[ngx-segment-community] Configuration',
  );

/**
 * Configures the core settings for the Segment Analytics library.
 *
 * It provides the mandatory settings for `provideSegmentAnalytics`, as it defines the
 * write key, initialization mode, and global behaviors like timeouts or obfuscation.
 *
 * @example
 * ```ts
 * provideSegmentAnalytics(
 *  withSettings({
 *    writeKey: 'YOUR_WRITE_KEY',
 *    initializationMode: 'automatic',
 *    debug: !environment.production
 *   })
 * )
 * ```
 *
 * @param config - The main configuration object for Segment.
 */
export function withSettings(
  config: SegmentAnalyticsSettings,
): SegmentSettings {
  return makeSegmentConfig(SegmentConfigKind.Settings, [
    {
      provide: SEGMENT_ANALYTICS_SETTINGS,
      useValue: config,
    },
  ]);
}

/**
 * A factory function that returns a Segment Source Middleware.
 *
 * By requiring a factory function rather than the middleware itself, you are able to use
 * Angular's `inject()` function to grab services (like an `AuthService` or `Store`)
 * from the root injector tree before returning the actual middleware logic.
 *
 * @returns A standard Segment `MiddlewareFunction`.
 */
export type SegmentSourceMiddlewareFn = () => MiddlewareFunction;
export const SEGMENT_SOURCE_MIDDLEWARE = new InjectionToken<
  SegmentSourceMiddlewareFn[]
>('[ngx-segment-community] Source Middleware');

/**
 * Allows you to register source middlewares, which are functions that can manipulate
 * the event payload and filter events on a per-source basis,
 *
 * In essence, these middlewares let developers to extend Analytics.js with custom code that runs on every event.
 * Middlewares have full access to the DOM and Browser API, and helps customers enrich and transform event payloads.
 *
 * **NOTE:**
 * You must provide a **factory function** that returns the actual middleware function. This allows you to use Angular's
 * `inject()` function to grab services from the root injector tree.
 *
 * @example
 * ```ts
 * provideSegmentAnalytics(
 *  withSettings({...}),
 *  withSourceMiddlewares([
 *    () => {
 *      const auth = inject(AuthService); // Safe DI access!
 *      return ({ payload, next }) => {
 *        if (auth.isLoggedIn) payload.obj.userId = auth.id;
 *        next(payload);
 *      };
 *    }
 *   ])
 * )
 * ```
 *
 * @param sourceMiddlewares - An array of factory functions returning source middleware functions.
 *
 * @see {@link https://www.twilio.com/docs/segment/connections/sources/catalog/libraries/website/javascript/middleware#using-source-middlewares | Source Middleware Spec}
 */
export function withSourceMiddlewares(
  sourceMiddlewares: SegmentSourceMiddlewareFn[],
) {
  return makeSegmentConfig(SegmentConfigKind.SMiddleware, [
    ...sourceMiddlewares.map((sm) => ({
      provide: SEGMENT_SOURCE_MIDDLEWARE,
      useValue: sm satisfies SegmentSourceMiddlewareFn,
      multi: true,
    })),
  ]);
}

/**
 * Configuration for destination middlewares.
 *
 * Destination middlewares allow you to transform or drop events right before they are sent
 * to a specific integration (e.g., 'Google Analytics' or 'Mixpanel').
 */
export interface SegmentDestinationMiddlewareFn {
  /**
   * The exact name of the integration to apply the middleware to (e.g., 'Google Analytics').
   * To apply a middleware to all device-mode destinations (excluding Segment.io), use the wildcard `'*'`.
   */
  integrationName: string;

  /**
   * An array of factory functions returning destination middlewares.
   *
   * **⚠️ CRITICAL LIMITATION:**
   * Destination middleware ONLY acts on data sent to destinations in **device-mode** * (integrations loaded directly
   * in the user's browser). It cannot transform data sent from Segment's servers to cloud-mode endpoints.
   *
   * Note that you must provide a factory function that returns a destination middleware function. This factory function
   * runs in the root injection context.
   */
  middlewares: Array<() => DestinationMiddlewareFunction>;
}

export const SEGMENT_DESTINATION_MIDDLEWARE = new InjectionToken<
  SegmentDestinationMiddlewareFn[]
>('[ngx-segment-community] Destination Middleware');

/**
 * Allows you to register destination middlewares, which are functions that can intercept and mutate events
 * right before they are sent to a specific integration
 *
 * In essence, these middlewares let developers to extend Analytics.js with custom code that runs on every event.
 * Middlewares have full access to the DOM and Browser API, and helps customers enrich and transform event payloads.
 *
 * **⚠️ CRITICAL LIMITATION:**
 * Destination middleware ONLY acts on data sent to destinations in **device-mode** (integrations loaded directly
 * in the user's browser, like Google Analytics). It cannot transform data sent from Segment's servers to cloud-mode
 * endpoints.
 *
 * Note that you must provide a factory function that returns a destination middleware function. This factory function
 * runs in the root injection context.
 *
 * @example
 * ```ts
 * provideSegmentAnalytics(
 *  withSettings({...}),
 *  withDestinationMiddlewares([
 *   {
 *     integrationName: 'Google Analytics',
 *     middlewares: [
 *       () => ({ payload, next }) => {
 *         // Mutate GA-specific payload
 *         next(payload);
 *       }
 *      ]
 *     }
 *   ])
 * )
 * ```
 *
 * @param destinationMiddlewares - An array of factory functions returning destination middleware functions.
 *
 * @see {@link https://www.twilio.com/docs/segment/connections/sources/catalog/libraries/website/javascript/middleware#using-destination-middlewares | Destination Middleware Spec}
 */
export function withDestinationMiddlewares(
  destinationMiddlewares: SegmentDestinationMiddlewareFn[],
) {
  return makeSegmentConfig(SegmentConfigKind.DMiddleware, [
    ...destinationMiddlewares.map((dm) => ({
      provide: SEGMENT_DESTINATION_MIDDLEWARE,
      useValue: dm satisfies SegmentDestinationMiddlewareFn,
      multi: true,
    })),
  ]);
}

/**
 * A factory function that returns a Segment Plugin.
 *
 * Returning the Plugin via a factory function allows you to safely use Angular's `inject()`
 * for Dependency Injection.
 *
 * @returns A Segment `Plugin` object.
 */
export type SegmentPluginFn = () => Plugin;
export const SEGMENT_PLUGIN = new InjectionToken<SegmentPluginFn[]>(
  '[ngx-segment-community] Plugin',
);

/**
 * Registers modern Segment Plugins to interact with the event timeline. Plugins can augment functionality,
 * enrich data, and control the flow and delivery of events.
 *
 * Plugins and source middleware accomplish the same thing, but plugins are significantly more powerful
 * (though more verbose to implement).
 *
 * For basic use cases like adding event fields or dropping specific events, use source middlewares. If you
 * need more granular control of the lifecycle, or want to be able to abort the Segment initialization, you should use plugins.
 *
 * Note that you must provide a factory function that returns a plugin object. This factory function
 * runs in the root injection context.
 *
 * @example
 * ```ts
 * provideSegmentAnalytics(
 *  withSettings({...}),
 *  withPlugins([
 *    () => {
 *    const router = inject(Router);
 *    return {
 *      name: 'Angular Router Plugin',
 *      type: 'enrichment',
 *      version: '1.0.0',
 *      isLoaded: () => true,
 *      load: () => Promise.resolve(),
 *      track: (ctx) => {
 *        ctx.event.properties.url = router.url;
 *        return ctx;
 *        }
 *      };
 *    }
 *  ])
 * )
 * ```
 *
 * @param plugins - An array of factory functions returning plugin objects.
 *
 * @see {@link https://www.twilio.com/docs/segment/connections/sources/catalog/libraries/website/javascript#advanced-plugin-api | Plugin API Spec}
 */
export function withPlugins(plugins: SegmentPluginFn[]) {
  return makeSegmentConfig(SegmentConfigKind.Plugin, [
    ...plugins.map((p) => ({
      provide: SEGMENT_PLUGIN,
      useValue: p satisfies SegmentPluginFn,
      multi: true,
    })),
  ]);
}

/**
 * Configures and initializes the Segment Analytics integration for the application.
 *
 * This function must be used in the root `providers` array (e.g., in `app.config.ts`).
 * It establishes the core settings and optionally registers advanced features like Plugins and Middlewares.
 *
 * @example
 * ```ts
 * export const appConfig: ApplicationConfig = {
 *  providers: [
 *    provideSegmentAnalytics(
 *      withSettings({ writeKey: environment.segmentKey }),
 *      withPlugins([ myCustomPluginFactory ]),
 *      withSourceMiddlewares([ myMiddlewareFactory ])
 *    )
 *  ]
 * };
 * ```
 *
 * @param settings - The mandatory static configuration (Write Key, CDN, etc), provided via `withSettings()`.
 * @param features - Optional behavioral features via `withPlugins()`, `withSourceMiddlewares()`, etc.
 */
export function provideSegmentAnalytics(
  settings: SegmentSettings,
  ...features: SegmentFeatures[]
): EnvironmentProviders {
  const settingsProvider = settings.ɵprovider;
  const featureProviders = features?.map((i) => i.ɵprovider) ?? [];

  return makeEnvironmentProviders([
    settingsProvider,
    ...featureProviders,
    SegmentService,
  ]);
}
